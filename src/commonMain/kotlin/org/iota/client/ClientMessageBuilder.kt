// Automatically generated by flapigen
package org.iota.client

import kotlin.jvm.Synchronized

class ClientMessageBuilder {
    private constructor() {}

    /**
     * Sets the seed.
     * @param seed The seed to use
     */
    fun withSeed(seed: String): ClientMessageBuilder {
        val ret = do_withSeed(mNativeObj, seed)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Sets the account index.
     * @param account_index The index to set
     */
    fun withAccountIndex(account_index: Long): ClientMessageBuilder {
        val ret =
            do_withAccountIndex(mNativeObj, account_index)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Sets the index of the address to start looking for balance.
     * @param initial_address_index The initial index to start address search from
     */
    fun withInitialAddressIndex(initial_address_index: Long): ClientMessageBuilder {
        val ret = do_withInitialAddressIndex(
            mNativeObj,
            initial_address_index
        )
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Set a custom input(transaction output)
     * @param input The custom input
     */
    fun withInput(input: UtxoInput): ClientMessageBuilder {
        val a0 = input.mNativeObj
        input.mNativeObj = 0
        val ret = do_withInput(mNativeObj, a0)
        val convRet = ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
        //TODO  java.lang.ref.Reference.reachabilityFence(input)
        return convRet
    }

    /**
     * Set a custom range in which to search for addresses for custom inputs. Default: 0..100
     * @param low Low end of input range (0)
     * @param high Upper end of input range (100)
     */
    fun withInputRange(low: Long, high: Long): ClientMessageBuilder {
        val ret =
            do_withInputRange(mNativeObj, low, high)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Insert the output address and amount to spent. The amount cannot be zero.
     * @param address The address we send to
     * @param amount The amount to send (> 0)
     */
    fun withOutput(address: String, amount: Long): ClientMessageBuilder {
        val ret =
            do_withOutput(mNativeObj, address, amount)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Set a dust allowance transfer to the builder, address needs to be Bech32 encoded
     * @param address The Bech32 encoded address we send to
     * @param amount The amount to send (> 0)
     */
    fun withDustAllowanceOutput(
        address: String,
        amount: Long
    ): ClientMessageBuilder {
        val ret = do_withDustAllowanceOutput(
            mNativeObj,
            address,
            amount
        )
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Set a transfer to the builder, address needs to be hex encoded
     * @param address The hex encoded address we send to
     * @param amount The amount to send (> 0)
     */
    fun withOutputHex(address: String, amount: Long): ClientMessageBuilder {
        val ret =
            do_withOutputHex(mNativeObj, address, amount)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Set indexation to the builder
     * @param index The index to use
     */
    fun withIndexVec(index: ByteArray): ClientMessageBuilder {
        val ret = do_withIndexVec(mNativeObj, index)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Set indexation to the builder
     * @param index The index to use
     */
    fun withIndexString(index: String): ClientMessageBuilder {
        val ret =
            do_withIndexString(mNativeObj, index)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Set data to the builder
     * @param data The data to use
     */
    fun withData(data: ByteArray): ClientMessageBuilder {
        val ret = do_withData(mNativeObj, data)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Set data to the builder
     * @param data The data to use
     */
    fun withDataString(data: String): ClientMessageBuilder {
        val ret = do_withDataString(mNativeObj, data)
        return ClientMessageBuilder(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Prepare a transaction. Used as parameter for `signTransaction`
     */
    fun prepareTransaction(): PreparedTransactionData {
        val ret = do_prepareTransaction(mNativeObj)
        return PreparedTransactionData(InternalPointerMarker.RAW_PTR, ret)
    }

    /**
     * Sign the transaction. inputsRangeLow and high to 0 for not using an input range
     * @param prepared_transaction_data The completely prepared transaction
     * @param seed The seed used to prepare the transaction
     * @param inputs_range_low Lower input used for getting adresses (default: 0)
     * @param inputs_range_high Upper input used for getting adresses (default: 100)
     */
    fun signTransaction(
        prepared_transaction_data: PreparedTransactionData,
        seed: String,
        inputs_range_low: Long,
        inputs_range_high: Long
    ): org.iota.client.MessagePayload {
        val a0 = prepared_transaction_data.mNativeObj
        prepared_transaction_data.mNativeObj = 0
        val ret = do_signTransaction(mNativeObj, a0, seed, inputs_range_low, inputs_range_high)
        val convRet: org.iota.client.MessagePayload =
            org.iota.client.MessagePayload(InternalPointerMarker.RAW_PTR, ret)
        //TODO   java.lang.ref.Reference.reachabilityFence(prepared_transaction_data)
        return convRet
    }

    /**
     * Consume the builder and return the message made with the specific payload
     * @param payload A prepared and signed MessagePayload
     */
    fun finish(payload: org.iota.client.MessagePayload): org.iota.client.Message {
        val a0: Long = payload.mNativeObj
        payload.mNativeObj = 0
        val ret = do_finish(mNativeObj, a0)
        val convRet: org.iota.client.Message =
            org.iota.client.Message(InternalPointerMarker.RAW_PTR, ret)
        //TODO   java.lang.ref.Reference.reachabilityFence(payload)
        return convRet
    }

    /**
     * Consume the builder and return the message made with the specific payload
     * @param payload A prepared and signed TransactionPayload
     */
    fun finishTransaction(payload: TransactionPayload): org.iota.client.Message {
        val a0 = payload.mNativeObj
        payload.mNativeObj = 0
        val ret = do_finishTransaction(mNativeObj, a0)
        val convRet: org.iota.client.Message =
            org.iota.client.Message(InternalPointerMarker.RAW_PTR, ret)
        //TODO  //TODO   java.lang.ref.Reference.reachabilityFence(payload)
        return convRet
    }

    /**
     * Consume the builder and return the message made with the specific payload
     * @param payload A prepared and signed MilestonePayload
     */
    fun finishMilestone(payload: org.iota.client.MilestonePayload): org.iota.client.Message {
        val a0: Long = payload.mNativeObj
        payload.mNativeObj = 0
        val ret = do_finishMilestone(mNativeObj, a0)
        val convRet: org.iota.client.Message =
            org.iota.client.Message(InternalPointerMarker.RAW_PTR, ret)
        //TODO  java.lang.ref.Reference.reachabilityFence(payload)
        return convRet
    }

    /**
     * Consume the builder and return the message made with the specific payload
     * @param payload A prepared and signed IndexationPayload
     */
    fun finishIndex(payload: org.iota.client.IndexationPayload): org.iota.client.Message {
        val a0: Long = payload.mNativeObj
        payload.mNativeObj = 0
        val ret = do_finishIndex(mNativeObj, a0)
        val convRet: org.iota.client.Message =
            org.iota.client.Message(InternalPointerMarker.RAW_PTR, ret)
        //TODO   java.lang.ref.Reference.reachabilityFence(payload)
        return convRet
    }

    /**
     * Consume the builder and return the message made with the specific payload
     * @param payload A prepared and signed ReceiptPayload
     */
    fun finishReceipt(payload: ReceiptPayload): org.iota.client.Message {
        val a0 = payload.mNativeObj
        payload.mNativeObj = 0
        val ret = do_finishReceipt(mNativeObj, a0)
        val convRet: org.iota.client.Message =
            org.iota.client.Message(InternalPointerMarker.RAW_PTR, ret)
        //TODO   java.lang.ref.Reference.reachabilityFence(payload)
        return convRet
    }

    /**
     * Consume the builder and return the message made with the specific payload
     * @param payload A prepared and signed TreasuryPayload
     */
    fun finishTreasury(payload: TreasuryPayload): org.iota.client.Message {
        val a0 = payload.mNativeObj
        payload.mNativeObj = 0
        val ret = do_finishTreasury(mNativeObj, a0)
        val convRet: org.iota.client.Message =
            org.iota.client.Message(InternalPointerMarker.RAW_PTR, ret)
        //TODO    java.lang.ref.Reference.reachabilityFence(payload)
        return convRet
    }

    /**
     * Consume the builder and return the message
     */
    fun finish(): org.iota.client.Message {
        val ret = do_finish(mNativeObj)
        return org.iota.client.Message(InternalPointerMarker.RAW_PTR, ret)
    }

    @Synchronized
    fun delete() {
        if (mNativeObj != 0L) {
            do_delete(mNativeObj)
            mNativeObj = 0
        }
    }

    @Throws(Throwable::class)
    protected fun finalize() {
        try {
            delete()
        } finally {
          //  super.finalize()
        }
    }

    /*package*/
    internal constructor(marker: InternalPointerMarker, ptr: Long) {
        check(marker === InternalPointerMarker.RAW_PTR)
        mNativeObj = ptr
    }

    /*package*/
    var mNativeObj: Long = 0

    companion object {
        private external fun do_withSeed(self: Long, seed: String): Long
        private external fun do_withAccountIndex(self: Long, account_index: Long): Long
        private external fun do_withInitialAddressIndex(
            self: Long,
            initial_address_index: Long
        ): Long

        private external fun do_withInput(self: Long, input: Long): Long
        private external fun do_withInputRange(self: Long, low: Long, high: Long): Long
        private external fun do_withOutput(self: Long, address: String, amount: Long): Long
        private external fun do_withDustAllowanceOutput(
            self: Long,
            address: String,
            amount: Long
        ): Long

        private external fun do_withOutputHex(self: Long, address: String, amount: Long): Long
        private external fun do_withIndexVec(self: Long, index: ByteArray): Long
        private external fun do_withIndexString(self: Long, index: String): Long
        private external fun do_withData(self: Long, data: ByteArray): Long
        private external fun do_withDataString(self: Long, data: String): Long
        private external fun do_prepareTransaction(self: Long): Long
        private external fun do_signTransaction(
            self: Long,
            prepared_transaction_data: Long,
            seed: String,
            inputs_range_low: Long,
            inputs_range_high: Long
        ): Long

        private external fun do_finish(self: Long, payload: Long): Long
        private external fun do_finishTransaction(self: Long, payload: Long): Long
        private external fun do_finishMilestone(self: Long, payload: Long): Long
        private external fun do_finishIndex(self: Long, payload: Long): Long
        private external fun do_finishReceipt(self: Long, payload: Long): Long
        private external fun do_finishTreasury(self: Long, payload: Long): Long
        private external fun do_finish(self: Long): Long
        private external fun do_delete(me: Long)
    }
}